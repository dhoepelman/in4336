\documentclass{sig-alternate}

\usepackage[ampersand]{easylist}
\usepackage{amsmath}

\usepackage{etoolbox}
\makeatletter
\def\@copyrightspace{\relax}
\makeatother

%\numberwithin{equation}{subsection}

\begin{document}

\title{Project report}

\subtitle{IN4336 Combinatorial Algorithms\\Project 3: Graph Coloring: applications, approximations and
solvers}

\numberofauthors{2}

\author{
\alignauthor
David Hoepelman\\
       \affaddr{1521969}\\
\alignauthor
Luis Garcia Rosario\\
       \affaddr{4062949}
}

\maketitle

%\begin{abstract}
%content...
%end{abstract}

\begin{abstract}

\end{abstract}

% Lingeling was chosen because it performed well in a large number of categories in the recent SAT Competition 2014 (http://www.satcompetition.org/2014/) contest

\section{Introduction}

Solvers for NP-Hard problems can be used to solve instances of other NP-Hard problems by polynomially transforming the other problem instance. This is called an encoding.
This possibility makes it feasible to make highly-optimized solving algorithms called solvers for certain relatively general NP-Hard problems.

For most popular problems multiple solvers exists, and benchmarks are available or contests are held to compare them.
However comparisons between problems are rarer and in this project we will do such a comparison.
We want to see if some problems are more suitable to encode other problems in or if the choice of problem to encode to makes little impact.

Another question is whether translations into intermediary problems add significant overhead.
While we know that polynomial transformations do not increase the complexity of a NP-Hard problem, it might still have a practical impact in how fast a problem instance can be solved or what the largest solvable problem instance is.
With this we want to see if encodings can be viably done in smaller easier steps, or if it is better to encode the problem directly into the target problem.

We formulated the following research question for this project:

\begin{enumerate}
\item[RQ1]{Is there a speed difference between different target problems when solving an identical translated problem instance?}
\item[RQ2]{Are intermediate transformations viable?}
	\begin{enumerate}
	\item[RQ2.1]{Does an intermediate transformation significantly decrease the speed with which problem instances can be solved?}
	\item[RQ2.2]{Does an intermediate transformation decrease the size of the largest possible problem instances which can be solved?}
	\end{enumerate}
\end{enumerate}

In answering our research questions we will focus on solvers for \emph{Integer Linear Programming} (ILP), \emph{Satisfiability} (SAT) and \emph{Satisfiability Modulo Theories} (SMT).

As problems to encode we took \emph{Resource Constrained Project Scheduling Problem} (RCPSP) and \emph{Graph Coloring} (GC).

\section {Target problems}

\subsubsection*{Satisfiability (SAT)}

The satisfiability problem is informally defined as given a boolean formula in conjunctive normal form (CNF), find an assignment that makes the formula true.
A formula is in CNF if it is a conjunction of clauses ($C_1 \wedge C_2 \wedge \ldots \wedge C_n$) where each clause is a disjunction of literals ($l_1 \lor l_2 \lor \ldots \lor l_n$) where each literal is a variable or the negation of a variable ($p$ or $\neg p$).
All propositional formulas can be converted to CNF.
A SAT solver will find either a valid assignment for the given formula, or will report that it is unsatisfiable.

\subsubsection*{Satisfiability Modulo Theories (SMT)}

Satisfiability Modulo Theories is a generalization of satisfiability.
A SMT problem instance is still a given formula, and the problem is to find out if it is satisfiable.
However, a variable can now be a predicate, a function which evaluates to a boolean, over non-boolean variables and operators.
Commonly SMT solvers support integer, real, integer array and bitvector variables and linear or non-linear arithmatic, but other extensions are possible.

The concrete advantage of this is that certain constraints which are hard to specifiy in a pure boolean formula can now be specified in a more natural language.

\subsubsection*{Integer Linear Programming (ILP)}

An Integer Linear Program (ILP) is a linear program that has the additional contraint that all variables take integer values. An ILP solver is used to solve a combinatorial optimization problem.

\section{Solving optimization problems with decidability solvers}

\section{Graph Coloring}

The graph coloring problem is one of the Karp's 21 original NP-Complete problems \cite{karp1972reducibility}.
Graph coloring exists in several variants, but they are all easily reducible to the vertex coloring problem. We chose the optimization variant of the vertex coloring problem which is informally defined as given an undirected graph $G = (V,E)$, find the minimal number of colors $k$ needed to color each vertex so that no adjacent vertex shares a color. More formally:
\begin{subequations}
\begin{align*}
        & G = (V,E) & E \subseteq V^2\\
        & map : V \rightarrow [1,k] & k \in \mathbb{N} \\
        & \text{with } map(v) \neq map(w) & (v,w) \in E \\
        & VC = min\{k | map : V \rightarrow [1,k]\}
\end{align*}
\end{subequations}


\subsection{SAT}

Satisfiability is a decision problem. This makes it impossible to directly encode the decision version of GC. Our approaches to get around this are detailed in section \ref{subsec:OptToDec}. For now it means that when encoding GC in SAT $k$ is a parameter of the translation.

We adopted the encoding from \cite{cs395tGCtoSAT}. We define a variable for every node and color combination $p_{vi} (v \in V, i \in [1,k])$. If node $v$ has color $i$ then $p_{vi}$, otherwise $\neg p_{vi}$. The following clauses ensure that the assignment will be valid for the GC instance:

\setcounter{equation}{1}
\begin{subequations}
\begin{align}
        & \bigvee_{1 \leq i \leq k} p_{vi}& v \in V\\
        & \neg p_{vi} \lor \neg p_{vj} & v \in V, 1 \leq i < j \leq k \\
        & \neg p_{vi} \lor \neg p_{wi} & v \in V, 1 \leq i \leq k
\end{align}
\end{subequations}

Clauses of type 2a ensures that every node has one or more colors. Clauses of type 2b ensures every node has at most one color. Clauses of type 2c ensure that nodes that share an edge do not have the same color.

This encoding has $O(|V| k)$ variables and $O(|E|+|V| k^2)$ clauses.

There is an alternative encoding defined in TODO. . We did not have time to implement and test this encoding.

\subsection{SMT}

\subsection{ILP}
The combinatorial problem of graph coloring can also be formulated as an 0-1 ILP. An advantage of using ILP is that it can solve optimization problems. The 0-1 ILP formulation of the graph coloring problem, which is a NP-hard minimization problem, can be done by taking the set of nodes V = {1,...,\emph{n}} of the graph $G = (V,E)$ and the number of colors \emph{k} = |V| = \emph{n}. Then, each color is represented by a binary variable \emph{$y_k$}, with \emph{k} = 1,...,\emph{n}, that indicatates whether color \emph{k} is used (\emph{$y_k$} = 1) or not (\emph{$y_k$} = 0). An objective function is formed by adding up these variables ($\sum\limits_{k=1}^n \emph{$y_k$}$) with the goal to obtain the minimum sum with the minimum number of the variables \emph{$y_k$} that are equal to 1. Furthermore, a binary variable \emph{$x_{ik}$} is used for each node-color combination to indicate whether node \emph{i} has received a color \emph{k} (\emph{$x_{ik}$} = 1) or not (\emph{$x_{ik}$} = 0). In the resulting 0-1 ILP in formal description listed below, adopted from \cite{faigle2002mathprogramming}, contraint (1) guarantees that each node is colored, (2) node \emph{i} receives color \emph{k} only if color \emph{k} has been used, (3) adjecent nodes should have different colors :
\begin{subequations}
\begin{align*}
        & min \sum\limits_{k=1}^n \emph{$y_k$} & \emph{s.t.} & & (1) & & \sum\limits_{k=1}^n \emph{$x_{ik}$} = 1 & & \emph{i} = 1,...,\emph{n} \\
        &  & & & (2) & & \emph{$x_{ik}$} - \emph{$y_k$} \leq 0 & & \emph{i,k} = 1,...,\emph{n} \\
        &  & & & (3) & &  \emph{$x_{ik}$} + \emph{$x_{jk}$} \leq 1 & & (i,j) \in E, \emph{k} = 1,...,\emph{n} \\
        &  & & & (4) & & 0 \leq \emph{$x_{ik}$}, \emph{$y_k$} \leq 1 & & \\
        &  & & & (5) & & \emph{$x_{ik}$}, \emph{$y_k$} \in \mathbb{Z} & &
\end{align*}
\end{subequations}

\section{RCPSP}

\subsection{Bounds}

Both encodings need upper and lower bounds.

\subsection{SAT}

\subsection{SMT}

\subsection{ILP}

\section{Experimental Setup}

\section{Results}

\section{Related Work}

%TODO: Deze referenties in de tekst verwerken of anders onzichtbaar opnemen in de 
\cite{alves2013resource}
\cite{abio2014encoding}
\cite{wu2013exploiting}
\cite{velev2009exploiting}
\cite{horbach2010boolean}
\cite{klein1999computing}
\cite{mingozzi1998exact}
\cite{sharma2011polynomial}
\cite{ramani2004breaking}
\cite{schutt2011explaining}
\cite{wille2008using}
\cite{malaguti2010survey}
\cite{cs395tGCtoSAT}

\section{Conclusion}

\bibliographystyle{acm}
\bibliography{in4336_report}

\end{document}