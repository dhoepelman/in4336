\documentclass{sig-alternate}

\usepackage[ampersand]{easylist}
\usepackage{amsmath}

\usepackage{etoolbox}
\makeatletter
\def\@copyrightspace{\relax}
\makeatother



\begin{document}

\title{Project report}

\subtitle{IN4336 Combinatorial Algorithms\\Project 3: Graph Coloring: applications, approximations and
solvers}

\numberofauthors{2}

\author{
\alignauthor
David Hoepelman\\
       \affaddr{1521969}\\
\alignauthor
Luis Garcia\\
       \affaddr{4062949}
}

\maketitle

%\begin{abstract}
%content...
%end{abstract}

\begin{abstract}

\end{abstract}

% Lingeling was chosen because it performed well in a large number of categories in the recent SAT Competition 2014 (http://www.satcompetition.org/2014/) contest

\section{Introduction}

Solvers for NP-Hard problems can be used to solve instances of other NP-Hard problems by polynomially transforming the other problem instance. This is called an encoding.
This possibility makes it feasible to make highly-optimized solving algorithms called solvers for certain relatively general NP-Hard problems.

For most popular problems multiple solvers exists, and benchmarks are available or contests are held to compare them.
However comparisons between problems are rarer and in this project we will do such a comparison.
We want to see if some problems are more suitable to encode other problems in or if the choice of problem to encode to makes little impact.

Another question is whether translations into intermediary problems add significant overhead.
While we know that polynomial transformations do not increase the complexity of a NP-Hard problem, it might still have a practical impact in how fast a problem instance can be solved or what the largest solvable problem instance is.
With this we want to see if encodings can be viably done in smaller easier steps, or if it is better to encode the problem directly into the target problem.

We formulated the following research question for this project:

\begin{enumerate}
\item[RQ1]{Is there a speed difference between formalisms when solving an identical problem instance?}
\item[RQ2]{Are intermediate transformations viable?}
	\begin{enumerate}
	\item[RQ2.1]{Does an intermediate transformation significantly decrease the speed with which problem instances can be solved?}
	\item[RQ2.2]{Does an intermediate transformation decrease the size of the largest possible problem instances which can be solved?}
	\end{enumerate}
\end{enumerate}

In answering our research questions we will focus on solvers for \emph{Integer Linear Programming} (ILP), \emph{Satisfiability} (SAT) and \emph{Satisfiability Modulo Theories} (SMT).

As problems to encode we took \emph{Resource Constrained Project Scheduling Problem} (RCPSP) and \emph{Graph Coloring} (GC).

\section{Encodings}

\subsection{Graph Coloring}

The graph coloring problem is one of the Karp's 21 original NP-Complete problems \cite{karp1972reducibility}.
Graph coloring exists in several variants, but they are all easily reducible to the vertex coloring problem. We chose the optimization variant of the vertex coloring problem which is informally defined as given an undirected graph $G = (V,E)$, find the minimal number of colors $k$ needed to color each vertex so that no adjacent vertex shares a color. More formally:
\begin{subequations}
\begin{align*}
        & G = (V,E) & E \subseteq V^2\\
        & map : V \rightarrow [1,k] & k \in \mathbb{N} \\
        & map(v) \neq map(w) & (v,w) \in E \\
        & VC = min\{k | map : V \rightarrow [1,k]\}
\end{align*}
\end{subequations}

\subsubsection{SAT}
\subsubsection{ILP}
The combinatorial problem of graph coloring can also be formulated in 0-1 ILP. An advantage of using ILP is that it can solve optimization problems. The formulation of the graph coloring problem in 0-1 ILP can be done by taking the set of nodes V = {1,...,\emph{n}} and the number of colors \emph{k} = |V| = \emph{n}. Then, each color is represented by a binary variable \emph{$y_k$}, with \emph{k} = 1,...,\emph{n}, that indicatate whether color \emph{k} is used (\emph{$y_k$} = 1) or not (\emph{$y_k$} = 0). An objective function is formed by adding up these variables ($\sum\limits_{k=1}^n \emph{$y_k$}$) to obtain the minimum number of these variable equal to zero. Furthermore, a binary variable \emph{$x_{i_k}$} is used for each node-color combination to indicate whether node \emph{i} has received a color \emph{k} (\emph{$x_{ik}$} = 1) or not (\emph{$x_{ik}$} = 0). The resulting 0-1 ILP in formal description:
\begin{subequations}
\begin{align*}
        & min \sum\limits_{k=1}^n \emph{$y_k$} & \emph{s.t.} & & (1) & & \sum\limits_{k=1}^n \emph{$x_{ik}$} = 1 & & \emph{i} = 1,...,\emph{n} \\
        &  & & & (2) & & \emph{$x_{ik}$} - \emph{$y_k$} \leq 0 & & \emph{i,k} = 1,...,\emph{n} \\
        &  & & & (3) & &  \emph{$x_{ik}$} + \emph{$x_{jk}$} \leq 1 & & (i,j) \in E, \emph{k} = 1,...,\emph{n} \\
        &  & & & (4) & & 0 \leq \emph{$x_{ik}$}, \emph{$y_k$} \leq 1 & & \\
        &  & & & (5) & & \emph{$x_{ik}$}, \emph{$y_k$} \in \mathbb{Z} & &
\end{align*}
\end{subequations}

\subsubsection{SMT}

\subsection{RCPSP}

\subsubsection{SAT}
\subsubsection{ILP}

\section{Experimental Setup}

\section{Results}

\section{Related Work}

%TODO: Deze referenties in de tekst verwerken of anders onzichtbaar opnemen in de 
\cite{alves2013resource}
\cite{abio2014encoding}
\cite{wu2013exploiting}
\cite{velev2009exploiting}
\cite{horbach2010boolean}
\cite{klein1999computing}
\cite{mingozzi1998exact}
\cite{sharma2011polynomial}
\cite{ramani2004breaking}
\cite{schutt2011explaining}
\cite{wille2008using}
\cite{malaguti2010survey}
\cite{cs395tGCtoSAT}

\section{Conclusion}

\bibliographystyle{acm}
\bibliography{in4336_report}

\end{document}