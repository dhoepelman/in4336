% !TeX spellcheck = en_US
\documentclass{sig-alternate}

\usepackage[ampersand]{easylist}
\usepackage{amsmath}

\usepackage{algpseudocode} 
\usepackage{algorithm}

\usepackage{etoolbox}
\makeatletter
\def\@copyrightspace{\relax}
\makeatother

\newcommand{\mli}[1]{\mathit{#1}}

%\numberwithin{equation}{subsection}

\begin{document}

\title{Project report}

\subtitle{IN4336 Combinatorial Algorithms\\Project 3: Graph Coloring: applications, approximations and
solvers}

\numberofauthors{2}

\author{
\alignauthor
David Hoepelman\\
       \affaddr{1521969}\\
\alignauthor
Luis Garcia Rosario\\
       \affaddr{4062949}
}

\maketitle

%\begin{abstract}
%content...
%end{abstract}

\begin{abstract}

\end{abstract}

% Lingeling was chosen because it performed well in a large number of categories in the recent SAT Competition 2014 (http://www.satcompetition.org/2014/) contest

\section{Introduction}

Solvers for NP-Hard problems can be used to solve instances of other NP-Hard problems by polynomially transforming the other problem instance. This is called an encoding.
This possibility makes it feasible to make highly-optimized solving algorithms called solvers for certain relatively general NP-Hard problems.

For most popular problems multiple solvers exists, and benchmarks are available or contests are held to compare them.
However comparisons between problems are rarer and in this project we will do such a comparison.
We want to see if some problems are more suitable to encode other problems in or if the choice of problem to encode to makes little impact.

Another question is whether translations into intermediary problems add significant overhead.
While we know that polynomial transformations do not increase the complexity of a NP-Hard problem, it might still have a practical impact in how fast a problem instance can be solved or what the largest solvable problem instance is.
With this we want to see if encodings can be viably done in smaller easier steps, or if it is better to encode the problem directly into the target problem.

We formulated the following research question for this project:

\begin{enumerate}
\item[RQ1]{Is there a speed difference between different target problems when solving an identical translated problem instance?}
\item[RQ2]{Are intermediate transformations viable?}
	\begin{enumerate}
	\item[RQ2.1]{Does an intermediate transformation significantly decrease the speed with which problem instances can be solved?}
	\item[RQ2.2]{Does an intermediate transformation decrease the size of the largest possible problem instances which can be solved?}
	\end{enumerate}
\end{enumerate}

In answering our research questions we will focus on solvers for \emph{Integer Linear Programming} (ILP), \emph{Satisfiability} (SAT) and \emph{Satisfiability Modulo Theories} (SMT).

As problems to encode we will focus on the \emph{Resource Constrained Project Scheduling Problem} (RCPSP) and \emph{Graph Coloring} (GC).

\section {Target problems}

\subsubsection*{Satisfiability (SAT)}

The satisfiability problem is informally defined as given a boolean formula in conjunctive normal form (CNF), find an assignment that makes the formula true.
A formula is in CNF if it is a conjunction of clauses ($C_1 \wedge C_2 \wedge \ldots \wedge C_n$) where each clause is a disjunction of literals ($l_1 \lor l_2 \lor \ldots \lor l_n$) where each literal is a variable or the negation of a variable ($p$ or $\neg p$).
All propositional formulas can be converted to CNF.
A SAT solver will find either a valid assignment for the given formula, or will report that it is unsatisfiable.

\subsubsection*{Satisfiability Modulo Theories (SMT)}

Satisfiability Modulo Theories is a generalization of satisfiability.
A SMT problem instance is still a given formula, and the problem is to find out if it is satisfiable.
However, a variable can now be a predicate, a function which evaluates to a boolean, over non-boolean variables and operators.
Commonly SMT solvers support integer, real, integer array and bitvector variables and linear or non-linear arithmatic, but other extensions are possible.

The concrete advantage of this is that certain constraints which are hard to specifiy in a pure boolean formula can now be specified in a more natural language.

\subsubsection*{Integer Linear Programming (ILP)}

An Integer Linear Program is a linear program (LP) that has the additional contraint that all variables must be integers. 
An ILP problem is an optimization problem where the objective is to maximize or minimize some value. 
The encoding of an optimization problem into ILP starts by composing an objective function in order to find the optimal objective value.
Then, the objective function is subjected to one or more constraints functions. Each function listed representing a different constraint.
The variables used in these functions may be bounded, e.g. in 0-1 ILP encoding variables can take a value of 0 or 1.
Finally, the last constraint in ILP is the integrallity constraint, meaning that all variables must take integers.

\section{Solving optimization problems with decidability solvers}
\label{sec:OptWithDec}

A decidability solver finds a feasible solution to a problem instance.
In practice one does often not only which to find \emph{a} feasible solution, but one wants to find \emph{the best} feasible solution out of all feasible solutions.
This is called an optimization problem.

ILP is an optimization problem and can thus naturally be used as a target for optimization problems.
To use decidability solvers for an optimization problem one can formulate the optimization problem as a sequence of decision problems $P$ with cost $c \in \mathbb{N}$.
In each step the solver looks for a solution to $P_c$.

We independently though of two ways to go through this sequence, but they are identical too the approaches described by Wille et. Al \cite{wille2008using}.
We will use their terminology.

The first approach called the \emph{iterative approach} starts at the lower bound of the possible costs $c = \mli{LB}$, usually $\mli{LB} = 0$.
While the solver can find no solution for $P_c$, $c$ is incremented.
In pseudocode:

\begin{algorithmic}
\State $c \gets \mli{UB}$
\While {not $solvable$}
	\State $P \gets encode(instance, c)$
	\State $solvable \gets solve(P)$
	\If {not $solvable$}
		\State $c++$
	\EndIf
\EndWhile
\State $\mli{OPT} \gets c$
\end{algorithmic}

This approach has the obvious disadvantage that $\mli{OPT}-\mli{LB}$ iterations are needed which is especially problematic if $\mli{OPT}$ is large

An alternative approach is too determine increasingly better lower and upper bounds.
If $P_c$ is determined feasible, one can look for a solution to $P_{c'}$ with $c' < c$. Likewise if $P_c$ is unfeasible, one can look for a solution to $P_{c'}$ with $c' > c$.
The minimal cost $OPT$ is found when $P_{OPT-1}$ is unfeasible, and $P_{\mli{OPT}}$ is feasible. This is called to approximation approach.
In pseudocode:

\begin{algorithmic}
\While {$\mli{LB} \neq \mli{UB} - 1$}
	\State $c = \mli{LB} + \lceil \frac{\mli{UB} - \mli{LB}}{2} \rceil$
	\State $P \gets encode(instance, c)$
	\State $solvable \gets solve(P)$
	\If {$solvable$}
		\State $\mli{UB} \gets c$
	\Else
		\State $\mli{LB} \gets c$
	\EndIf
\EndWhile
\State $\mli{OPT} \gets \mli{UB}$
\end{algorithmic}

By performing a binary search over all possible $c$, we set the maximum number of iterations to $\lceil log_2(\mli{UB}-\mli{LB}) \rceil$.

During our experiments we encountered the problem that the first problem $P_{\frac{1}{2}\mli{UB}}$ took a long time to encode, even though it usually was satisfiable.
To get around this better upper bounds were needed, for which we tested both theoretical upper bounds and approximation algorithms.


\section{Graph Coloring}

The graph coloring problem is one of the Karp's 21 original NP-Complete problems \cite{karp1972reducibility}.
Graph coloring exists in several variants, but they are all reducible to the vertex coloring problem.
We chose the optimization variant of the vertex coloring problem which is informally defined as given an undirected graph $G = (V,E)$, find the minimal number of colors $k$ needed to color each vertex so that no adjacent vertex shares a color.
More formally:
\begin{subequations}
\begin{align*}
        & G = (V,E) & E \subseteq V^2\\
        & map : V \rightarrow [1,k] & k \in \mathbb{N} \\
        & \text{with } map(v) \neq map(w) & (v,w) \in E \\
        & VC = min\{k \ | \  map : V \rightarrow [1,k]\}
\end{align*}
\end{subequations}

\subsection{Bounds}

The possible values of $k$ have clearly defined bounds.
All graphs except the empty graph will need at least $1$ color, and all graphs with an edge will need at least $2$ colors.
We stuck with an lower bound of $0$ for the approximation approach and $1$ for the iteration approach.

The trivial upper bound for a graph is $|V|$ colors, as every vertex can have its own unique color in that case.
Another useful upper bound is $max(degree(v))+1 \text{ for } v \in V$, the degree being the number of neighbors or edges of a node.
This u

\subsection{SAT encoding}

As satisfiability is a decision problem $k$ needs to be a parameter of the transformation, see section \ref{sec:OptWithDec} for how we determined $k$.

We adopted the encoding from \cite{cs395tGCtoSAT}.
We define a variable for every node and color combination $p_{vi} (v \in V, i \in [1,k])$.
If node $v$ has color $i$ then $p_{vi}$, otherwise $\neg p_{vi}$.
The following clauses ensure that the assignment will be valid for the GC instance:

\setcounter{equation}{1}
\begin{subequations}
\begin{align}
        & \bigvee_{1 \leq i \leq k} p_{vi}& v \in V\\
        & \neg p_{vi} \lor \neg p_{vj} & v \in V, 1 \leq i < j \leq k \\
        & \neg p_{vi} \lor \neg p_{wi} & v \in V, 1 \leq i \leq k
\end{align}
\end{subequations}

Clauses of type 2a ensures that every node has one or more colors. Clauses of type 2b ensures every node has at most one color. Clauses of type 2c ensure that nodes that share an edge do not have the same color.
The encoding uses $O(|V| k)$ variables and $O(|E|+|V| \cdot k^2)$ clauses.

There is another possible encoding which uses $O(|V| \cdot \lceil{log_2{k}\rceil})$ variables and $O(2^{\lceil{log_2k}\rceil} \cdot |E|+(2^{\lceil{log_2k\rceil}}-k) \cdot |V|)$ clauses which shows promising results in \cite{wille2008using}.
Unfortunately we did not have time to implement and test this encoding, we refer to section \ref{relatedandfuture}.

\subsection{SMT encoding}
Our SMT encoding is identical to our SAT encoding.
There are several candidate encodings which do use this additional expressive power, which are detailed in the future work section.

\subsection{ILP encoding}
The combinatorial problem of graph coloring can also be formulated as an 0-1 ILP in which the variables are binary variables. 
An advantage of using ILP is that unlike SAT and SMT, it can solve optimization problems. 
The 0-1 ILP formulation of the graph coloring problem,
can be done by taking the set of nodes V = {1,...,\emph{n}} of the graph G and the number of 
colors is $1 \leq \emph{k} \leq |V|$. By observing that a graph cannot use more colors than it's maximum 
degree, we put the upper bound for color \emph{k} as the highest degree of G.
Then, each color is represented by a binary variable \emph{$y_k$}, 
with \emph{k} = 1,...,\emph{n}, that indicatates whether color \emph{k} is used (\emph{$y_k$} = 1) or 
not (\emph{$y_k$} = 0). An objective function is formed by adding up these variables 
($\sum\limits_{k=1}^n \emph{$y_k$}$) to obtain the minimum sum. That is, we want the minimum number 
of the variables \emph{$y_k$} that are equal to 1. Furthermore, a binary variable \emph{$x_{ik}$} is 
used for each node-color combination to indicate whether node \emph{i} has received a color \emph{k} 
(\emph{$x_{ik}$} = 1) or not (\emph{$x_{ik}$} = 0). In the resulting 0-1 ILP in formal description 
listed below, adopted from \cite{faigle2002mathprogramming}, contraint (1) guarantees that each node 
is colored, (2) node \emph{i} receives color \emph{k} only if color \emph{k} has been used, (3) adjecent nodes should have different colors:
\begin{subequations}
\begin{align*}
        & & & min \sum\limits_{k=1}^n \emph{$y_k$} & & \\
        &  (1) & & \sum\limits_{k=1}^n \emph{$x_{ik}$} = 1 & & \emph{i} = 1,...,\emph{n} \\
        &  (2) & & \emph{$x_{ik}$} - \emph{$y_k$} \leq 0 & & \emph{i,k} = 1,...,\emph{n} \\
        &  (3) & &  \emph{$x_{ik}$} + \emph{$x_{jk}$} \leq 1 & & (i,j) \in E, \emph{k} = 1,...,\emph{n} \\
        &  (4) & & 0 \leq \emph{$x_{ik}$}, \emph{$y_k$} \leq 1 & & \\
        &  (5) & & \emph{$x_{ik}$}, \emph{$y_k$} \in \mathbb{Z} & &
\end{align*}
\end{subequations}

\section{RCPSP}
The Resource Constraint Project Scheduling Problem (RCPSP) is informally defined as given a project with resource limits, jobs with dependencies and resource consumption of jobs, find an optimal schedule so that at no time too much resources are consumed and the project is completed at the earliest time possible.

\subsection{Formal definition and notation}
Given a project $P$ with:
\begin{itemize}
\item A set of jobs $V = \{1,\ldots,N\}$ 
\item A set of resources $R = \{1,\ldots,M\}$
\item Precedence relations $(i,j) \in prec \subset V \times V$ which means job $j$ is dependent upon job $i$
\item Durations $d_i \in \mathbb{N}$ for each job $i \in V$
\item Resource limits $R_j$ for each $j \in R$
\item Job resource consumptions $r_i,j$ for each job $i \in V$ and resource $j \in R$
\end{itemize}

define
\begin{itemize}
\item The start time $s_i$ of job $i$ in a schedule
\item The in-progess 
\end{itemize}

\subsection{Bounds}

Both encodings need upper and lower bounds.

\subsection{SAT}

\subsection{SMT}

\subsection{ILP}
The 0-1 ILP model for RCPSP is formulated as in \cite{horbach2010boolean} and in \cite{mingozzi1998exact}.
For each activity (job) $i \in V$ and for each period $t \in \{es_i,...,ls_i\}$ a binary variable $x_{it}$ indicates whether an activity $\emph{i}$ starts at period $t (x_{it} = 1) or not (x_{it} = 0)$.
Same as with SAT, we determine for each activity \emph{i} its earliest ($es_i$) and its latest ($ls_i$) start times, its earliest ($ef_i$) and its latest ($lf_i$) finish times, using the critical-path method by Floyd-Warshall algorithm.
With the variables $u_{it}$ we can indicate for each activity $i$ if it is executing at period $t$ ($u_{it} = 1$) or not executing ($u_{it} = 0$).
The resulting 0-1 ILP project makespan optimization in formal description listed below.
\begin{subequations}
\begin{align*}
        & & & min\{x_{n+1},T\} & & {i} \in {V} \\
        &  (1) & & \sum\limits_{{t}\in{es_i,...,ls_i}} {x_{it}} = 1 & & {i} \in {V}, {t} \in {es_i,...,ls_i}, {t} \in {es_i,...,ls_i} + {d_i} - 1 \\
        &  (2) & & \sum\limits_{{l}\in{es_j,...,t-d_j}} {x_{jl}} \geq {x_{it}} & & {(j,i)} \in {E}, {t} \in {es_i,...,ls_i} \\
        &  (3) & & \sum\limits_{{i}\in{V,}{es_i}\leq{t}\leq{ls_i}} {r_{ik}}{u_{it}} \leq {R_k} & & {t} \in {0,1,...,{T}}, {k} \in {R} \\
        &  (4) & & {x_{ik}} + {x_{jk}} \leq 1 & & (i,j) \in E, {k} = 1,...,{n} \\
        &  (5) & & {x_{00}} = 1 & & \\
        &  (6) & & {x_{it}} \in {0, 1} & & \\
        &  (7) & & {u_{it}}, {x_{it}} \in \mathbb{Z} & &
\end{align*}
\end{subequations}

\section{Experimental Setup}

\section{Results}

\section{relatedandfuture}
Besides the main focus of our research, solving the graph coloring problem, we would have liked to include
the RCPSP problem.
%TODO: However we couldn't get to solve the SAT encoding of RCPSP, due to...
We implemented an ILP encoding of the RCPSP problem to compare the solving time with the SAT encoding, 
but we didn't have the SAT solving times to compare with. 
It can be usefull to explore the SMT encoding of RCPSP, as it can work with among others integer, 
integer array and bitvector variables, and use its solving times and compare it with the ILP encoding.

%TODO: Deze referenties in de tekst verwerken of anders onzichtbaar opnemen in de 
\cite{alves2013resource}
\cite{abio2014encoding}
\cite{wu2013exploiting}
\cite{velev2009exploiting}
\cite{horbach2010boolean}
\cite{klein1999computing}
\cite{mingozzi1998exact}
\cite{sharma2011polynomial}
\cite{ramani2004breaking}
\cite{schutt2011explaining}
\cite{wille2008using}
\cite{malaguti2010survey}
\cite{cs395tGCtoSAT}

\section{Conclusion}

\bibliographystyle{acm}
\bibliography{in4336_report}

\end{document}